= Overview
:sectnums:
:source-language: 

The properties we care most about are often those of the runtime values, not some static
notion. Thus *spec* is not a type system.

*spec* will allow (only) namespace-qualified keywords and symbols to name specs.

[listing]
----
clojure.spec
clojure.spec.gen
clojure.spec.test
----


The `spec` library allows you to leverage all of the functions you already have---there is
no special dictionary of predicates. Any existing Clojure function that takes a single
argument and returns a truthy value is a valid predicate spec.


== Predicates

The `conform` function takes something that can be a spec and a data value. Here we are
passing a predicate which is implicitly converted into a spec.

[listing]
----
(s/conform <spec> <value>)

spec ::= predicates | spec-identifer
----

[source]
....
(s/conform even? 1000)
; => 1000

(s/conform even? 1001)
; => :clojure.spec/invalid
....


[listing]
----
(s/valid? <spec> <value>)
----

[source]
....
(s/valid? even? 10)
; => true

(s/valid? even? 11)
; => false
....


== Annotated Tag

This `or` spec is the first case we've seen that involves a choice during validity
checking. Each choice is annotated with a tag (here, `:name` and `:id`) and those tags
give the branches names that can be used to understand or enrich the data returned from
conform and other spec functions.

[source]
....
(s/def ::name-or-id (s/or :name string?
                          :id   int?))

(s/valid? ::name-or-id "abc") ;; true
(s/valid? ::name-or-id 100) ;; true
(s/valid? ::name-or-id :foo) ;; false
....


(s/conform (s/and 
             (s/map-of string? any?) 
             #(= [1 "john"] (map % ["id" "name"])))
           {"id" 1, "name" "john"})
;;=> {"id" 1, "name" "john"}


== Homogenous collections

* homogenous collection of arbitrary size:  `coll-of`, `map-of`

* homogenous/heterogenous collection of fixed size: `tuple` +
fixed-size positional collection with fields of known type at different positions. 


== Sequences

Specs for sequences/vectors use a set of standard regular expression operators, with the
standard semantics of regular expressions:

=== regex operator

heterogenuous ordered sequences

* `cat` - concatenation of predicates/patterns
* `alt` - choice among alternative predicates/patterns

Like `or`, both `cat` and `alt` tag their "parts" 

* `*` - 0 or more of a predicate/pattern
* `+` - 1 or more of a predicate/pattern
* `?` - 0 or 1 of a predicate/pattern
* `&` 

== Spec'ing functions

* fdef: function or macro
* fspec: higher-order function

== Generators

All specs are also designed to act as generators of sample data that conforms to the spec
(a critical requirement for property-based testing).

[listing]
----
(s/gen <spec>)
----

(s/def ::kws (s/with-gen (s/and keyword? #(= (namespace %) "my.domain"))
                         #(s/gen #{:my.domain/name :my.domain/occupation :my.domain/id})))



(def kw-gen-3 (gen/fmap #(keyword "my.domain" %)
                         (gen/such-that #(not= % "")
                                         (gen/string-alphanumeric))))

(s/def ::hello
       (s/with-gen #(clojure.string/includes? % "hello")
                   #(gen/fmap (fn [[s1 s2]] (str s1 "hello" s2))
                              (gen/tuple (gen/string-alphanumeric) (gen/string-alphanumeric)))))

"It is better to have 100 functions operate on one data abstraction than 10 functions
on 10 data structures."  -- Alan Perlis's Epigrams on Programming in 1982



