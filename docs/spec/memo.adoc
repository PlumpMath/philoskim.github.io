= clojure.spec
:sectnums:
:source-language: clojure

== clojure.spec이 제공하는 주요 기능들

* spec은 데이터의 구조를 정의한다.
* spce은 데이터의 유효성(validation)을 확인한다.
* spec은 데이터의 구조분해(destructuring: 일종의 코드 parsing) 기능을 제공한다.
* spec은 자동 테스트 케이스 생성(generative testing) 기능을 제공한다.


== clojure.spec의 특징들

=== spec은 predicate으로 이루어져 있다

[sidebar]
.predicate (진위 함수)
****
* 한 개의 인수를 받고, 논리적 참/거짓을 반환하는 함수이다.
** 논리적 거짓: ``nil``과 `false`
** 논리적 참: ``nil``과 `false`를 제외한 모든 값. {nbsp} {nbsp} {nbsp} 예) `0 "" [] () {} #{} pass:q[...]` 

* 이 규정만 준수하면 Clojure의 어떤 함수도 predicate이 될 수 있다.
****

=== spec은 composable(조합 가능)하다

단순한 spec들을 조합해서 복잡한 spec을 정의할 수 있다. pass:q[-->] reusability(재사용성)의 증가

[source]
....
(def suit? #{:club :diamond :heart :spade})
(def rank? (into #{:jack :queen :king :ace} (range 2 11)))
(def deck (for [suit suit? rank rank?] [rank suit]))

(s/def ::card (s/tuple rank? suit?))
(s/def ::hand (s/* ::card))

(s/def ::name string?)
(s/def ::score int?)
(s/def ::player (s/keys :req [::name ::score ::hand]))

(s/def ::players (s/* ::player))
(s/def ::deck (s/* ::card))
(s/def ::game (s/keys :req [::players ::deck]))
....



== 세부 내용들


=== conform

[source]
....
(s/conform even? 1000)
; => 1000

(s/conform even? 1001)
; => :clojure.spec/invalid
....


=== valid?

[source]
....
(s/valid? even? 1000)
; => true

(s/valid? even? 1001)
; => false
....


[source]
....
(s/valid? #(> % 5) 10)
; => true

(s/valid? #(> % 5) 0)
; => false
....


[source]
....
(#{:club :diamond :heart :spade} :club)
; => :club

(s/valid? #{:club :diamond :heart :spade} :club)
; => true


(#{:club :diamond :heart :spade} 42)
; => nil

(s/valid? #{:club :diamond :heart :spade} 42)
; => false
....


=== def: spec 등록하기
   
def는 spec을 global registery에 등록한다. global registery에 등록하는 이유는, 이미 정의한
spec을 다른 이름공간이나 다른 라이브러리에서도 사용(reusability)할 수 있도록 하기 위해서다.


[listing]
----
(s/def <namespaced-keyword> <spec>)
----

==== namespaced keyword 

[source]
....
spec-guide.core> :aaa
:aaa

spec-guide.core> ::aaa
:spec-guide.core/aaa

spec-guide.core> :new-ns:aaa
:new-ns:aaa
....


[source]
....
(s/def ::suit #{:club :diamond :heart :spade})

(s/conform ::suit :club)
; => :club
....


==== and/or: predicate 조합하기

[source]
....
(s/def ::big-even (s/and int? even? #(> % 1000)))

(s/valid? ::big-even :foo)     ; => false
(s/valid? ::big-even 11)       ; => false
(s/valid? ::big-even 100000)   ; => true
....


[source]
....
(s/explain ::big-even :foo)
; >> val: :foo fails
;    spec: :spec-guide.core/big-even
;    predicate: int?

(s/explain ::big-even 11) 
; >> val: 11 fails 
;    spec: :spec-guide.core/big-even
;    predicate: even?

(s/explain ::big-even 100000) 
; >> Success!
....


`or` 매크로처럼 선택(choide) Ehsms 분기(branch)가 발생하는 경우에는 tag를 붙여주어야
한다. 이런 경우에는 `conform` 함수도 tag를 붙여 반환한다.


[source]
....
(s/def ::name-or-id (s/or :name string?
                          :id   int?))

(s/valid? ::name-or-id "abc")   ; => true
(s/valid? ::name-or-id 100)     ; => true
(s/valid? ::name-or-id :foo)    ; => false

(s/conform ::name-or-id "abc")   ; => [:name "abc"]
(s/conform ::name-or-id 100)     ; => [:id 100]
(s/conform ::name-or-id :foo)    ; => :clojure.spec/invalid


(s/explain ::name-or-id "abc")
; >> Success!
; => nil

(s/explain ::name-or-id :foo)
; >> val: :foo fails 
;    spec: :spec-guide.core/name-or-id
;    at: [:name]
;    predicate: string?
;
;    val: :foo fails
;    spec: :spec-guide.core/name-or-id
;    at: [:id]
;    predicate: int?
; => nil

(s/explain-str ::name-or-id :foo)
; => "val: :foo fails spec: :spec-guide.core/name-or-id at: [:name] predicate: string?\nval: :foo fails spec: :spec-guide.core/name-or-id at: [:id] predicate: int?\n"

(s/explain-data ::name-or-id :foo)
; => #:clojure.spec{:problems ({:path [:name], 
;                               :pred string?,
;                               :val :foo,
;                               :via [:spec-guide.core/name-or-id],
;                               :in []}
;                              {:path [:id],
;                               :pred int?,
;                               :val :foo,
;                               :via [:spec-guide.core/name-or-id],
;                               :in []})}

(s/explain-data ::name-or-id "abc")
; => nil
....


* explain: 실패한 이유를 stdout에 출력한다.
* explain-str: 실패한 이유를 문자열로 반환한다.
* explain-data: 실패한 이유를 Clojure 데이터형으로 반환한다.

=== Collections: coll-of, tuple, and map-of

* coll-of: homogenous collections of any size
* tuple: fixed-size positional collection with fields of known type at different positions.
* map-of: maps with homogenous key and value predicates.

* `coll-of`, ``map-of``는 모든 요소둘에 대해 spec validation을 수행. 
* `every`, `every-kv`는 ``s/*coll-check-limit*``에 지정된 개수(default:101)만큼만 수행

[source]
....
s/*coll-check-limit*   ; => 101
....




=== Sequences

spec provides the standard regular expression operators to describe the structure of a
sequential data value:

[listing]
----
cat - concatenation of predicates/patterns
alt - choice among alternative predicates/patterns
* - 0 or more of a predicate/pattern
+ - 1 or more of a predicate/pattern
? - 0 or 1 of a predicate/pattern
& - takes a regex operator and constrains it with one or 
    more additional predicates. 
----

When regex ops are combined, they describe a single sequence. If you need to spec a nested
sequential collection, you must use an explicit call to `spec` to start a new nested regex
context.

=== Spec'ing functions: fdef


=== Higher order functions: fspec

=== Macros: fdef


== Generators

All specs are also designed to act as generators of sample data that conforms to the spec
(a critical requirement for property-based testing).

spec generators rely on the Clojure property testing library `test.check`.

=== Sampling Generators

The `gen` function can be used to obtain the generator for any spec.

You can generate a single sample value with generate or a series of samples with sample.

* generate: 1개의 sample을 생성
* sample: default로 10개의 sample을 생성. 추가로 개수를 지정할 수 있다.
* exercise: 'sample'과 '그 smaple에 conform 함수를 수행한 결과' 2개를 vector 형태로 번환한다.
* exercise-fn: fdef로 정의한 함수 spec에 대해 exercise를 수행한다. args와 반환값 2개를 vector 형태로 번환한다.

==== Using s/and Generators


==== Custom Generators


== Instrumentation and Testing

