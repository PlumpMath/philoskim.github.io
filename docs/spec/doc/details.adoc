= clojure.spec 세부 내용
:source-highlighter: coderay
:source-language: clojure
:sectnums:
:icons: font
:imagesdir: ../img
:linkcss:
:stylesdir: ../
:stylesheet: my-asciidoctor.css

* 이 발표에 사용한 clojure.spec 버전은 ``clojure 1.9.0-alpha14``이다.
* 여기에서 보여주는 예제들은 다음과 같은 이름공간에서 실행되었다.
+
[source]
....
(ns spec-guide.core
  (:require [clojure.spec :as s]
            [clojure.spec.gen :as gen]
            [clojure.spec.test :as stest]))
....
+
** clojure.spec: spec 정의 pass:[-->] Runtime type/value checking을 위해 필요
** clojure.spec.gen: generator 정의 pass:[-->] 자동 test-case 생성을 위해 필요
** clojure.spec.test: 자동 테스트 수행을 위해 필요


== clojure.spec

=== s/valid?

[listing]
----
(valid? spec value) => boolean

spec ::= predicate | namespaced-keyword
----

[source]
....
(s/valid? even? 10)            ; => true
(s/valid? string? "abc")       ; => true

(s/valid? #(> % 5) 10)         ; => true
(s/valid? #(> % 5) 0)          ; => false

(s/valid? #{10 20 30 40} 10)   ; => true
(s/valid? #{10 20 30 40} 50)   ; => false
....



=== s/def

``def``는 spec을 정의하고, 중앙 저장소에 이를 저장한다. 이렇게 spec을 global하게 저장하는
이유는 재사용도를 증가시키기 위해서다.
 
 
[listing]
----
(def namespaced-keyword spec) => namespaced-keyword

spec ::= predicate | namespaced-keyword
----

[source]
....
(s/def ::suit #{:club :diamond :heart :spade})
; => :spec-guide.core/suit
....


=== s/conform

[listing]
----
(confirm spec value)

spec ::= predicate | namespaced-keyword
----

[source]
....
(s/conform ::suit :club)    ; => :club
(s/conform ::suit :hello)   ; => :clojure.spec/invalid
....


=== spec의 합성

==== s/and

[listing]
----
(and spec+)

spec ::= predicate | namespaced-keyword
----


[source]
....
(s/def ::big-even (s/and int? even? #(> % 1000)))

(s/valid? ::big-even :foo)    ; => false
(s/valid? ::big-even 10)      ; => false
(s/valid? ::big-even 100000)  ; => true
....


==== s/or

[listing]
----
(or <tag spec>+)

tag  ::= keyowrd
spec ::= predicate | namespaced-keyword
----

``or``의 경우에는 spec 앞에 tag를 붙여 주어야 한다. 아래에 소개하는 ``cat``도
마찬가지이다. 

여러가지 경우의 수로 분기하는 경우에는 tag를 붙여 주는데, 나중에 분기되는 항목 중의 어느
항목에서 문제가 발생했는지 식별하기 위한 용도로 사용된다.

[source,subs="verbatim,quotes"]
....
(s/def ::name-or-id (s/or :name string?
                          :id   int?))

(s/valid? ::name-or-id "abc")    ; => true
(s/valid? ::name-or-id 100)      ; => true
(s/valid? ::name-or-id :foo)     ; => false

(s/conform ::name-or-id "abc")   ; => [#:name# "abc"]
(s/conform ::name-or-id 100)     ; => [#:id# 100]
(s/conform ::name-or-id :foo)    ; => :clojure.spec/invalid
....


=== s/explain

[listing]
----
(explain spec value)

spec ::= predicate | namespaced-keyword
----

``explain``은 spec을 통과하지 못한 이유를 설명해 준다.

[source]
....
(when (= (s/conform ::name-or-id :foo)
         :clojure.spec/invalid)
  (s/explain ::name-or-id :foo))
; >> val: :foo fails
;    spec: :spec-guide.core/name-or-id
;    at: [:name] predicate: string?
;
;    val: :foo fails
;    spec: :spec-guide.core/name-or-id
;    at: [:id] predicate: int?
;
; => nil

(s/explain ::name-or-id "tom")
; >> Success!
; => nil
....

* `s/explain`: 결과를 stdout에 출력한다.  
* `s/explain-str`: 결과를 문자열로 반환한다.
* `s/explain-data`: 결과를 클로저 데이터형으로 반환한다.

[source]
....
(s/explain-str ::name-or-id :foo)
; => "val: :foo fails spec: :spec-guide.core/name-or-id at: [:name] predicate: string?\nval: :foo fails spec: :spec-guide.core/name-or-id at: [:id] predicate: int?\n"

(s/explain-data ::name-or-id :foo)
; => #:clojure.spec{:problems ({:path [:name],
;                               :pred string?,
;                               :val :foo,
;                               :via [:spec-guide.core/name-or-id],
;                               :in []}
;                              {:path [:id],
;                               :pred int?,
;                               :val :foo,
;                               :via [:spec-guide.core/name-or-id],
;                               :in []})}
....


=== map 자료형의 spec 정의하기: s/keys

[listing]
----
(keys < keyword [namespacd-key+] >+)

keyword ::= :req | :opt | :req-un | :opt-un 
----

==== namespaced keys

[source,subs="verbatim,quotes"]
....
(s/def ::first-name string?)
(s/def ::last-name string?)
(s/def ::phone string?)

(s/def ::person (s/keys #:req# [::first-name ::last-name]
                        #:opt# [::phone]))
....


[source,subs="verbatim,quotes"]
....
(s/valid? ::person
  {#::first-name# "Elon"
   ::last-name "Musk"
   ::phone "010-1234-5678"})
; => true

(s/conform ::person
  {::first-name "Elon"
   ::last-name "Musk"})
; => #:spec-guide.core{:first-name "Elon", :last-name "Musk"}

(s/explain ::person
  {::first-name "Elon"})
; >> val: #:spec-guide.core{:first-name "Elon"} fails
;    spec: :spec-guide.core/person predicate: (contains? % :spec-guide.core/last-name)
....


==== unnamespaced keys

[source,subs="verbatim,quotes"]
....
(s/def :unq/person
  (s/keys #:req-un# [::first-name ::last-name]
          #:opt-un# [::phone]))
....

[source,subs="verbatim,quotes"]
....
(s/conform :unq/person
  {#:first-name# "Elon"
   :last-name "Musk"})
; => {:first-name "Elon", :last-name "Musk"}

(s/explain :unq/person
  {:first-name "Elon"})
; >> val: {:first-name "Elon"} fails
;    spec: :unq/person
;    predicate: (contains? % :last-name)
....















